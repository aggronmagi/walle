#+startup: content
#+title: walle

walle目标是开箱即用. 灵活配置. 高性能的服务框架.开发中...
#+begin_quote
开发阶段，API并不稳定
#+end_quote
* 进度
** TODO 网络层支持以下接口
 - [ ] gotcp
 - [ ] gnet
 - [ ] kcp
 - [X] websocket
** TODO 事件监听
 - [ ] 链接事件
 - [ ] 网络层事件
** TODO 服务注册与发现使用
 - [ ] etcd
** TODO 工具代码包
 - [ ] gpool
 - [ ] skeleton
** TODO 代码生成
 - [ ] excel配置相关
 - [ ] rpc、tcp代码
 - [ ] redis/mysql 代码
* 网络库
** 层级
 1. 底层接口. io层，只提供系统层级交互. read/write
 2. 中层接口. process层，定制处理流程. 已完成
 3. 高层接口. 业务逻辑层.
    手写代码,后续会分为2层. 
    1. 生成代码层
    2. 自定义逻辑层
*** io(transport)
io.Read io.Write 负责网络接口读写
**** 支持
 - 原生net/tcp
 - kcp https://github.com/xtaci/kcp-go
 - websocket https://github.com/gorilla/websocket/
 - gnet https://github.com/panjf2000/gnet
*** process -> 处理流程
**** network.Read
#+begin_example
io.Read ==>  PacketDispatcherFilter(Chain) => PacketCoder.Decode(Tee) => PacketCodec.Unmarshal => Router => CallChain(Middleware+LogicFunc)
#+end_example

**** network.Write
#+begin_example
MsgCodec.Marshal => PacketCodec.Marshal => PacketCoder.Encode => NetPackager.Write ==> io.Write
#+end_example

*** logic -> 逻辑处理(自定义生成/手写代码)

** 组件,接口
*** PacketDispatcherFilter 接口
PacketDispatcherFilter 用于控制之后的程序如何执行.可以在接收数据的时间开始就直接开始一个新的协程！
#+begin_src go
// PacketDispatcherFunc 消息分发 - 未解包
type PacketDispatcherFunc func(data []byte) (err error)
// PacketUnmarshalFilter
type PacketDispatcherFilter func(data []byte, next PacketDispatcherFunc) (err error)
#+end_src
*** PacketEncoder 接口
用于对原始数据包进行处理(加解密,压缩等)
#+begin_src go
type PacketEncoder interface {
	Encode(ctx Context, buf []byte) []byte
	Decode(ctx Context, buf []byte) []byte
}
#+end_src
*** PacketCodec 接口
用于序列化/反序列化 packet.Packet 消息
#+begin_src go
type PacketCodec interface {
	Marshal(p *packet.Packet) ([]byte, error)
	Unmarshal(data []byte, p *packet.Packet) error
}
#+end_src
*** MsgCodec 接口
用于序列化和反序列逻辑层网络消息 - ~ctx.Bind(Request)~ => ~Codec.Unmarshal()~
#+begin_src go
type Codec interface {
	Marshal(v interface{}) ([]byte, error)
	Unmarshal(data []byte, v interface{}) error
}
#+end_src
*** Router 接口
路由组件。当前支持string类型的name路由，和基于数字的路由。
*** CallChain
由中间件和逻辑处理函数组成的调用队列

可以定制的中间件及支持：
 - 监控中间件
 - 定制处理协程。可以讲后续流程放入指定协程处理。
 - 可以调用 process.Context.WithTimeout 设置整体流程超时。

*** Context
不同场景. Context不同.
 - tcp-client / tcp-server-session
 - rpc-client / rpc-server-session 
 - kafka/redis-stream/redis-list/mq
必须包含的项:
  - log
  - context.Context
可选的项: 
    - Packet
    - Timer
    - Server & Session
    - Client
      
** process 选项
*** 定制选项，业务方决定如何配置
#+begin_src go
// ProcessOption process option
//go:generate gogen option -n ProcessOption -o option.process.go
func walleProcessOption() interface{} {
	return map[string]interface{}{
		// log interface。 日志接口，也可以通过 server层WithSessionLogger去定制
		"Logger": (*zaplog.Logger)(zaplog.Default),
		// packet pool
		"PacketPool": packet.PacketPool(packet.DefaultPacketPool),
		// packet encoder
		"PacketEncode": PacketEncoder(&EmtpyPacketCoder{}),
		// packet codec
		"PacketCodec": PacketCodec(PacketCodecProtobuf),
		// message codec
		"MsgCodec": MessageCodec(MessageCodecProtobuf),
		// dispatch packet data filter 接收数据后，定制处理协程
		"DispatchDataFilter": PacketDispatcherFilter(DefaultPacketFilter),
		// load limit. return true to ignore packet. 负载限制。
		"LoadLimitFilter": func(ctx Context, count int64, req *packet.Packet) bool {
			return false
		},
	}
}

#+end_src
*** 内部选项。 用于封装server,client等操作。开发新的io支持。
#+begin_src go

// InnerOption use for process
//go:generate gogen option -n InnerOption -f Inner -o option.inner.go
func walleProcessInner() interface{} {
	return map[string]interface{}{
		// Output: write interface(net.Conn)
		"Output": io.Writer(nil),
		// Specify Real Context
		"NewContext": func(ctx Context, ud interface{}) Context {
			return ctx
		},
		// process context parent
		"ParentCtx": context.Context(context.Background()),
		// Sequence number 可以由创建方决定，是否每一个process独立计算Sequence
		"Sequence": AtomicNumber(&atomic.Int64{}),
		// load number interface。 同上。
		"Load": AtomicNumber(&atomic.Int64{}),
		// bind data 内部绑定数据
		"BindData": interface{}(nil),
		// process router. 路由。也是由创建方决定使用方式
		"Router": Router(nil),
	}
}
#+end_src


** websocket 选项
#+begin_src go
// ServerOption
//go:generate gogen option -n ServerOption -o option.server.go
func walleServer() interface{} {
	return map[string]interface{}{
		// Addr Server Addr. websocket监听地址
		"Addr": string(":8080"),
		// WsPath websocket server path。 路由
		"WsPath": string("/ws"),
		// Upgrade websocket upgrade
		"Upgrade": (*websocket.Upgrader)(DefaultUpgrade),
		// UpgradeFail upgrade fail notify.
		"UpgradeFail": func(w http.ResponseWriter, r *http.Request, reason error) {},
		// accepted load limit.链接数量限制
		"AcceptLoadLimit": func(sess Session, cnt int64) bool { return false },
		// Process Options 传递给process的选项。
		"ProcessOptions": []process.ProcessOption{},
		// process router。路由
		"Router": Router(nil),
		// SessionRouter custom session router。定制路由
		"SessionRouter": func(sess Session, global Router) (r Router) { return global },
		// log interface 日志接口
		"Logger": (*zaplog.Logger)(zaplog.Default),
		// SessionLogger custom session logger。定制日志接口
		"SessionLogger": func(sess Session, global *zaplog.Logger) (r *zaplog.Logger) { return global },
		// NewSession custom session。新链接通知
		"NewSession": func(in Session, r *http.Request) (Session, error) { return in, nil },
		// StopImmediately when session finish,business finish immediately.
		// 链接断开后，是否停止处理流程。 应该根据业务分析决定。
		"StopImmediately": false,
		// ReadTimeout read timetout
		"ReadTimeout": time.Duration(0),
		// WriteTimeout write timeout
		"WriteTimeout": time.Duration(0),
		// MaxMessageLimit limit message size
		"MaxMessageLimit": int(0),
		// Write network data method.
		"WriteMethods": WriteMethod(WriteAsync),
		// SendQueueSize async send queue size
		"SendQueueSize": int(1024),
		// Heartbeat use websocket ping/pong.
		"Heartbeat": time.Duration(0),
		// HttpServeMux custom set mux
		"HttpServeMux": (*http.ServeMux)(http.DefaultServeMux),
	}
}
#+end_src

[[./example/ws][websocket例子]]


